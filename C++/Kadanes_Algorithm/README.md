# 📂 Maximum Subarray Problem – From Brute Force to Kadane's Algorithm

## 🚀 Overview

This project explores different approaches to solving the **Maximum Subarray Problem**, starting from the most basic brute-force method to the highly efficient **Kadane’s Algorithm**.

---

## 🔍 What I Learned

### 1. **Subarray Traversal – Brute Force (O(n³))**

At first, I learned how to **generate all possible subarrays** using three nested loops. It was helpful for understanding how subarrays work, but very inefficient for large arrays.

### 2. **Finding Maximum Subarray – Brute Force (O(n³))**

Then I used the same triple loop method, but this time added logic to **calculate the sum of each subarray** and update the maximum. This approach was accurate but very slow (O(n³)).

### 3. **Kadane’s Algorithm – Efficient (O(n))**

Finally, I learned and implemented **Kadane’s Algorithm**, a smart way to solve the problem in **linear time**. It uses a running sum and resets it if it becomes negative, making it super fast and efficient.

---

## 📈 Time Complexities

| Method                   | Time Complexity |
| ------------------------ | --------------- |
| Brute Force Traversal    | O(n³)           |
| Brute Force Max Subarray | O(n³)           |
| Kadane’s Algorithm       | O(n)            |

---

## ✅ Outcome

By comparing these methods, I clearly saw the importance of optimization in coding. Kadane’s Algorithm not only saves time but also teaches how **greedy choices** and **smart resets** can make a big difference.

---
