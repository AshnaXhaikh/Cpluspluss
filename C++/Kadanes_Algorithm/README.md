# ğŸ“‚ Maximum Subarray Problem â€“ From Brute Force to Kadane's Algorithm

## ğŸš€ Overview

This project explores different approaches to solving the **Maximum Subarray Problem**, starting from the most basic brute-force method to the highly efficient **Kadaneâ€™s Algorithm**.

---

## ğŸ” What I Learned

### 1. **Subarray Traversal â€“ Brute Force (O(nÂ³))**

At first, I learned how to **generate all possible subarrays** using three nested loops. It was helpful for understanding how subarrays work, but very inefficient for large arrays.

### 2. **Finding Maximum Subarray â€“ Brute Force (O(nÂ³))**

Then I used the same triple loop method, but this time added logic to **calculate the sum of each subarray** and update the maximum. This approach was accurate but very slow (O(nÂ³)).

### 3. **Kadaneâ€™s Algorithm â€“ Efficient (O(n))**

Finally, I learned and implemented **Kadaneâ€™s Algorithm**, a smart way to solve the problem in **linear time**. It uses a running sum and resets it if it becomes negative, making it super fast and efficient.

---

## ğŸ“ˆ Time Complexities

| Method                   | Time Complexity |
| ------------------------ | --------------- |
| Brute Force Traversal    | O(nÂ³)           |
| Brute Force Max Subarray | O(nÂ³)           |
| Kadaneâ€™s Algorithm       | O(n)            |

---

## âœ… Outcome

By comparing these methods, I clearly saw the importance of optimization in coding. Kadaneâ€™s Algorithm not only saves time but also teaches how **greedy choices** and **smart resets** can make a big difference.

---
